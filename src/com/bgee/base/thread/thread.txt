1:	不要调用 Thread 类或 Runnable 对象的 run 方法。 直接调用 run 方法，只会执行同一个线程中的任务，
	而不会启动新线程。 应该调用 Thread.start 方法。 这个方法将创建一个执行 run 方法的新线程。
	
2：	当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。
	在临界区中使用适当的同步就可以避免竞态条件。
	
3：	自旋锁
	while(isLocked){
		wait();
	}
	
	当isLocked为true时，调用lock()的线程在wait()调用上阻塞等待。
	为防止该线程没有收到notify()调用也从wait()中返回（也称作虚假唤醒），
	这个线程会重新去检查isLocked条件以决定当前是否可以安全地继续执行还是需要重新保持等待，
	而不是认为线程被唤醒了就可以安全地继续执行了
	
	
4：	finally 调用 unlock
	lock.lock();
	try {
		//TODO
	} finally {
		lock.unlock();
	}
	

	如果用Lock来保护临界区，并且临界区有可能会抛出异常，那么在finally语句中调用unlock()就显得非常重要了。
	这样可以保证这个锁对象可以被解锁以便其它线程能继续对其加锁。
	
	
5：	线程状态

	1、新状态：线程对象已经创建，还没有在其上调用start()方法。

	2、可运行状态：当线程有资格运行，但调度程序还没有把它选定为运行线程时线程所处的状态。当start()方法调用时，线程首先进入可运行状态。
		在线程运行之后或者从阻塞、等待或睡眠状态回来后，也返回到可运行状态。

	3、运行状态：线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。

	4、等待/阻塞/睡眠状态：这是线程有资格运行时它所处的状态。实际上这个三状态组合为一种，其共同点是：线程仍旧是活的，但是当前没有条件运行。
		换句话说，它是可运行的，但是如果某件事件出现，他可能返回到可运行状态。

	5、死亡态：当线程的run()方法完成时就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。
		线程一旦死亡，就不能复生。如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。
		
		
		
6：	yield()

	暂停当前运行的线程 并运行其它线程
	
	
7：	join()
	让线程b 加入到 线程a 的尾部   a线程运行完毕后才能运行b
	
	join(n毫秒)
	让线程等待n毫秒   之后变为可运行状态
	
8:	只能同步方法，而不能同步变量和类；

9:	每个对象只有一个锁；当提到同步时，应该清楚在什么上同步？也就是说，在哪个对象上同步？

10:	不必同步类中所有的方法，类可以同时拥有同步和非同步方法。

11:	如果一个线程在对象上获得一个锁，就没有任何其他线程可以进入（该对象的）类中的任何一个同步方法。

12:	如果线程拥有同步和非同步方法，则非同步方法可以被多个线程自由访问而不受锁的限制。

13:	线程睡眠时，它所持的任何锁都不会释放。

14:	线程可以获得多个锁。比如，在一个对象的同步方法里面调用另外一个对象的同步方法，则获取了两个对象的同步锁。

