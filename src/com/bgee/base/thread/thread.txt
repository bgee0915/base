1:	不要调用 Thread 类或 Runnable 对象的 run 方法。 直接调用 run 方法，只会执行同一个线程中的任务，
	而不会启动新线程。 应该调用 Thread.start 方法。 这个方法将创建一个执行 run 方法的新线程。
	
2：	当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。
	在临界区中使用适当的同步就可以避免竞态条件。
	
3：	自旋锁
	while(isLocked){
		wait();
	}
	
	当isLocked为true时，调用lock()的线程在wait()调用上阻塞等待。
	为防止该线程没有收到notify()调用也从wait()中返回（也称作虚假唤醒），
	这个线程会重新去检查isLocked条件以决定当前是否可以安全地继续执行还是需要重新保持等待，
	而不是认为线程被唤醒了就可以安全地继续执行了
	
	
4：	finally 调用 unlock
	lock.lock();
	try {
		//TODO
	} finally {
		lock.unlock();
	}
	

	如果用Lock来保护临界区，并且临界区有可能会抛出异常，那么在finally语句中调用unlock()就显得非常重要了。
	这样可以保证这个锁对象可以被解锁以便其它线程能继续对其加锁。
	
	
5：	线程状态

	1、新状态：线程对象已经创建，还没有在其上调用start()方法。

	2、可运行状态：当线程有资格运行，但调度程序还没有把它选定为运行线程时线程所处的状态。当start()方法调用时，线程首先进入可运行状态。
		在线程运行之后或者从阻塞、等待或睡眠状态回来后，也返回到可运行状态。

	3、运行状态：线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。

	4、等待/阻塞/睡眠状态：这是线程有资格运行时它所处的状态。实际上这个三状态组合为一种，其共同点是：线程仍旧是活的，但是当前没有条件运行。
		换句话说，它是可运行的，但是如果某件事件出现，他可能返回到可运行状态。

	5、死亡态：当线程的run()方法完成时就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。
		线程一旦死亡，就不能复生。如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。
		
		
		
6：	yield()

	暂停当前运行的线程 并运行其它线程
	
	
7：	join()
	让线程b 加入到 线程a 的尾部   b线程运行完毕后才能运行b之后的代码
	
	join(n毫秒)
	让线程等待n毫秒   之后变为可运行状态
	
8:	只能同步方法，而不能同步变量和类；

9:	每个对象只有一个锁；当提到同步时，应该清楚在什么上同步？也就是说，在哪个对象上同步？

10:	不必同步类中所有的方法，类可以同时拥有同步和非同步方法。

11:	如果一个线程在对象上获得一个锁，就没有任何其他线程可以进入（该对象的）类中的任何一个同步方法。

12:	如果线程拥有同步和非同步方法，则非同步方法可以被多个线程自由访问而不受锁的限制。

13:	线程睡眠时，它所持的任何锁都不会释放。

14:	线程可以获得多个锁。比如，在一个对象的同步方法里面调用另外一个对象的同步方法，则获取了两个对象的同步锁。

15：	yield 和 sleep 的区别

	:sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；
	yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行

16：	wait 和 sleep 的区别

	　sleep()睡眠时，保持对象锁，仍然占有该锁；
　　　　而wait()睡眠时，释放对象锁。



17:	
	sleep(): 强迫一个线程睡眠Ｎ毫秒。 
　	isAlive(): 判断一个线程是否存活。 
	join(): 等待线程终止。 
	activeCount(): 程序中活跃的线程数。 
	enumerate(): 枚举程序中的线程。 
    currentThread(): 得到当前线程。 
	isDaemon(): 一个线程是否为守护线程。 
	setDaemon(): 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束) 
	setName(): 为线程设置一个名称。 
	wait(): 强迫一个线程等待。 
	notify(): 通知一个线程继续运行。 
	setPriority(): 设置一个线程的优先级。

18:	无论何时，只要有多于一个的线程访问给定的状态变量，而且其中某个线程会写入该变量，此时必须使用同步来协调线程对该变量的访问。

19：	一个对象是否应该是线程安全的取决于他是否会被多个线程访问。线程安全的这个性质，取决于程序中如何适用对象，而不是对象完成了什么。
	
20：	多个线程访问同一个变量 程序会存在隐患 可以以下方式修复
		1):	不要跨线程共享变量
		2):	是状态变量为不可变的
		3):	在任何访问状态变量的时候使用变量

21:	
	
	
	
	
	
	
	
	
	
	
	