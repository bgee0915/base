1:	不要调用 Thread 类或 Runnable 对象的 run 方法。 直接调用 run 方法，只会执行同一个线程中的任务，
	而不会启动新线程。 应该调用 Thread.start 方法。 这个方法将创建一个执行 run 方法的新线程。
	
2：	当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。
	在临界区中使用适当的同步就可以避免竞态条件。
	
3：	自旋锁
	while(isLocked){
		wait();
	}
	
	当isLocked为true时，调用lock()的线程在wait()调用上阻塞等待。
	为防止该线程没有收到notify()调用也从wait()中返回（也称作虚假唤醒），
	这个线程会重新去检查isLocked条件以决定当前是否可以安全地继续执行还是需要重新保持等待，
	而不是认为线程被唤醒了就可以安全地继续执行了
	
	
4：	finally 调用 unlock
	lock.lock();
	try {
		//TODO
	} finally {
		lock.unlock();
	}
	

	如果用Lock来保护临界区，并且临界区有可能会抛出异常，那么在finally语句中调用unlock()就显得非常重要了。
	这样可以保证这个锁对象可以被解锁以便其它线程能继续对其加锁。
	